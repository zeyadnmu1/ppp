
import os, io, datetime as dt
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
from auto_dj.io.cache import read_parquet
import pandas as _pd

@st.cache_data
def _smart_read(path:str):
    if path.lower().endswith('.csv'):
        return _pd.read_csv(path)
    return read_parquet(path)
from auto_dj.taste.model import load_taste, TasteModel
from auto_dj.recs.candidates import filter_candidates
from auto_dj.recs.rerank import rerank

st.set_page_config(page_title="Playlist Auto-DJ", page_icon="üéß", layout="wide")

@st.cache_data
def load_tracks(path: str):
    return _smart_read(path)

def kpi_cards(df: pd.DataFrame):
    c1, c2, c3 = st.columns(3)
    c1.metric("Tracks", len(df))
    c2.metric("Avg Valence", f"{df['valence'].mean():.2f}")
    c3.metric("Avg Energy", f"{df['energy'].mean():.2f}")

def scatter_valence_energy(df: pd.DataFrame, title: str):
    fig, ax = plt.subplots()
    ax.scatter(df["valence"], df["energy"], alpha=0.3, s=10)
    ax.set_xlabel("Valence"); ax.set_ylabel("Energy"); ax.set_title(title)
    st.pyplot(fig)

def try_load_taste(model_path: str) -> TasteModel | None:
    try: return load_taste(model_path)
    except Exception: return None

st.title("üéß Playlist Auto-DJ ‚Äî Mood-Aware Recommender")
st.caption("Explore your library, set a target vibe, and build a playlist.")

tab1, tab2, tab3 = st.tabs(["Explore", "Recommend", "Build Playlist"])

with tab1:
    st.subheader("Data")
    tracks_path = st.text_input("Curated tracks Parquet path", "data/curated/tracks.parquet")
    if os.path.exists(tracks_path):
        df = load_tracks(tracks_path)
        st.dataframe(df.head(50), use_container_width=True)
        kpi_cards(df); scatter_valence_energy(df, "Valence vs Energy")
    else:
        st.info("Provide a valid `data/curated/tracks.parquet` to explore.")

with tab2:
    st.subheader("Generate Recommendations")
    tracks_path = st.text_input("Tracks path", "data/curated/tracks.parquet", key="rec_path")
    model_path = st.text_input("Taste model (.joblib) path (optional)", "models/taste.joblib")
    mood = st.selectbox("Target mood", ["happy","energetic","calm","sad"], index=1)
    tempo = st.slider("Tempo (BPM)", 60, 200, (100, 150))
    energy = st.slider("Energy", 0.0, 1.0, (0.5, 0.9))
    k = st.slider("Playlist size (K)", 10, 100, 25, 5)
    alpha = st.slider("Taste vs Mood weight Œ±", 0.0, 1.0, 0.7, 0.05)
    epsilon = st.slider("Exploration Œµ", 0.0, 0.5, 0.1, 0.05)

    if os.path.exists(tracks_path):
        df = load_tracks(tracks_path)
        taste = try_load_taste(model_path) if os.path.exists(model_path) else None
        target_map = {"happy": (0.8, 0.7), "energetic": (0.6, 0.85), "calm": (0.4, 0.3), "sad": (0.2, 0.2)}
        target_v, target_e = target_map[mood]
        cands = filter_candidates(df, mood=mood, tempo_min=tempo[0], tempo_max=tempo[1],
                                  energy_min=energy[0], energy_max=energy[1])
        if len(cands) == 0:
            st.warning("No candidates with current filters.")
        else:
            recs = rerank(cands, taste, target_v, target_e, alpha=alpha, epsilon=epsilon, k=k)
            st.dataframe(recs[["track_id","track_name","artist_names","tempo","valence","energy","score"]],
                         use_container_width=True)
            st.session_state["recs_df"] = recs
            st.metric("Avg Valence", f"{recs['valence'].mean():.2f}")
            st.metric("Avg Energy", f"{recs['energy'].mean():.2f}")
            buf = io.BytesIO(); recs.to_csv(buf, index=False)
            st.download_button("‚¨áÔ∏è Download recs (CSV)", data=buf.getvalue(),
                               file_name=f"recs_{mood}_{dt.datetime.now().strftime('%Y%m%d_%H%M')}.csv")
    else:
        st.info("Set a valid tracks path.")

with tab3:
    st.subheader("Build Playlist on Spotify")
    recs_df = st.session_state.get("recs_df")
    if recs_df is None or len(recs_df) == 0:
        st.info("Generate recommendations first in the 'Recommend' tab.")
    else:
        name = st.text_input("Playlist name", f"Auto-DJ ‚Äì {dt.date.today().isoformat()}")
        desc = st.text_area("Description", "Generated by Playlist Auto-DJ")
        private = st.checkbox("Private playlist", value=True)
        if st.button("Create Spotify Playlist"):
            try:
                import spotipy
                from spotipy.oauth2 import SpotifyOAuth
                scope = "playlist-modify-private,playlist-modify-public"
                sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope=scope))
                user_id = sp.current_user()["id"]
                pl = sp.user_playlist_create(user=user_id, name=name, public=(not private), description=desc)
                uris = ["spotify:track:" + tid for tid in recs_df["track_id"].astype(str).tolist()]
                for i in range(0, len(uris), 100):
                    sp.playlist_add_items(pl["id"], uris[i:i+100])
                st.success(f"Created playlist: {pl.get('external_urls',{}).get('spotify','Open in Spotify')}")
            except Exception as e:
                st.error(f"Failed to create playlist: {e}")
